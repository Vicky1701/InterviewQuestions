# JPA, JDBC & Hibernate Interview Questions

## JPA (Java Persistence API) Questions

### What is JPA and how is it different from Hibernate?

**JPA (Java Persistence API):**
- JPA is a specification that defines a standard for object-relational mapping (ORM) in Java
- It's part of Java EE and provides a set of interfaces and annotations
- JPA is vendor-neutral and provides portability across different ORM implementations

**Hibernate:**
- Hibernate is an implementation of the JPA specification
- It's a concrete ORM framework that provides actual functionality
- Hibernate also has its own additional features beyond JPA specification

**Key Differences:**
- JPA is a specification; Hibernate is an implementation
- JPA provides interfaces; Hibernate provides concrete classes
- You can switch JPA implementations (Hibernate, EclipseLink, OpenJPA) without changing much code
- Hibernate offers additional features not covered by JPA specification

### Explain JPA as specification vs Hibernate as implementation

**JPA as Specification:**
```java
// JPA interfaces and annotations
import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class User {
    @Id
    private Long id;
    // JPA standard annotations
}

// JPA interface
EntityManager em = entityManagerFactory.createEntityManager();
```

**Hibernate as Implementation:**
```java
// Hibernate specific classes
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.annotations.Cache;

@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE) // Hibernate specific
public class User {
    @Id
    private Long id;
}

// Hibernate specific implementation
Session session = sessionFactory.openSession();
```

### Explain JPA entity lifecycle states

JPA entities have four lifecycle states:

#### 1. New (Transient)
- Entity object is created but not associated with EntityManager
- Not synchronized with database
- Has no database identity

```java
User user = new User(); // New/Transient state
user.setName("John");
```

#### 2. Managed (Persistent)
- Entity is associated with EntityManager and has database identity
- Changes are automatically synchronized with database
- Part of current persistence context

```java
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

// Becomes managed
User user = em.find(User.class, 1L); 
user.setName("Jane"); // Automatically synced to DB

// Or
User newUser = new User();
em.persist(newUser); // New -> Managed

em.getTransaction().commit();
```

#### 3. Detached
- Entity was managed but EntityManager is closed
- Has database identity but not synchronized
- Changes won't be automatically persisted

```java
EntityManager em = emf.createEntityManager();
User user = em.find(User.class, 1L); // Managed
em.close(); // Now user becomes Detached

user.setName("Bob"); // Won't be persisted automatically
```

#### 4. Removed
- Entity is scheduled for deletion
- Will be removed from database on transaction commit

```java
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

User user = em.find(User.class, 1L); // Managed
em.remove(user); // Managed -> Removed

em.getTransaction().commit(); // Actually deleted from DB
```

**State Transitions:**
- New → Managed: `persist()`, `merge()` (if not exists)
- Managed → Detached: `detach()`, `clear()`, `close()`
- Detached → Managed: `merge()`
- Managed → Removed: `remove()`
- Removed → Managed: `persist()` (before commit)

### What are JPA annotations? Explain commonly used ones

#### Core Annotations:

**@Entity**
```java
@Entity
@Table(name = "users") // Optional: specify table name
public class User {
    // Entity class
}
```
- Marks a class as JPA entity
- Must have no-arg constructor
- Cannot be final

**@Id**
```java
@Entity
public class User {
    @Id
    private Long id;
}
```
- Marks the primary key field
- Every entity must have exactly one @Id

**@GeneratedValue**
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
    @SequenceGenerator(name = "user_seq", sequenceName = "user_sequence")
    private Long id2;
    
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id3;
}
```
- **IDENTITY**: Database auto-increment
- **SEQUENCE**: Database sequence
- **TABLE**: Separate table for ID generation
- **AUTO**: Provider chooses strategy

**@Column**
```java
@Entity
public class User {
    @Column(name = "first_name", nullable = false, length = 50, unique = true)
    private String firstName;
    
    @Column(precision = 10, scale = 2)
    private BigDecimal salary;
}
```
- Maps field to database column
- Specifies column properties

**@Table**
```java
@Entity
@Table(name = "app_users", 
       schema = "hr",
       uniqueConstraints = @UniqueConstraint(columnNames = {"email"}))
public class User {
}
```
- Specifies table details
- Can define constraints, indexes

#### Relationship Annotations:

**@OneToMany**
```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Employee> employees;
}
```

**@ManyToOne**
```java
@Entity
public class Employee {
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
}
```

**@JoinColumn**
```java
@Entity
public class Employee {
    @ManyToOne
    @JoinColumn(name = "dept_id", nullable = false, foreignKey = @ForeignKey(name = "FK_EMP_DEPT"))
    private Department department;
}
```
- Specifies join column for relationships
- Defines foreign key properties

### What is the difference between @OneToMany and @ManyToOne?

#### @OneToMany
- One entity can be associated with multiple entities
- Typically mapped on the "one" side of relationship
- Often used with collections (List, Set)

#### @ManyToOne
- Many entities can be associated with one entity
- Mapped on the "many" side of relationship
- Uses single object reference

#### Bidirectional Relationship Example:
```java
// One side
@Entity
public class Department {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Employee> employees = new ArrayList<>();
    
    // Helper methods
    public void addEmployee(Employee employee) {
        employees.add(employee);
        employee.setDepartment(this);
    }
    
    public void removeEmployee(Employee employee) {
        employees.remove(employee);
        employee.setDepartment(null);
    }
}

// Many side
@Entity
public class Employee {
    @Id
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
}
```

#### Cascade Operations:
```java
@OneToMany(cascade = {
    CascadeType.PERSIST,  // Save children when parent is saved
    CascadeType.MERGE,    // Update children when parent is updated
    CascadeType.REMOVE,   // Delete children when parent is deleted
    CascadeType.REFRESH,  // Refresh children when parent is refreshed
    CascadeType.DETACH    // Detach children when parent is detached
})
private List<Employee> employees;

// Or use CascadeType.ALL for all operations
@OneToMany(cascade = CascadeType.ALL)
private List<Employee> employees;
```

### Explain fetch types in JPA - LAZY vs EAGER

#### LAZY Fetching
```java
@Entity
public class Department {
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "department")
    private List<Employee> employees; // Loaded only when accessed
}

// Usage
Department dept = em.find(Department.class, 1L);
// employees not loaded yet

List<Employee> emps = dept.getEmployees(); // Now employees are loaded
```

**Characteristics:**
- Data loaded on-demand when first accessed
- Reduces initial query time and memory usage
- May cause LazyInitializationException if accessed outside session
- Default for @OneToMany and @ManyToMany

#### EAGER Fetching
```java
@Entity
public class Employee {
    @ManyToOne(fetch = FetchType.EAGER)
    private Department department; // Always loaded with Employee
}

// Usage
Employee emp = em.find(Employee.class, 1L);
// department is already loaded
String deptName = emp.getDepartment().getName(); // No additional query
```

**Characteristics:**
- Data loaded immediately with parent entity
- Can cause performance issues with large datasets
- No LazyInitializationException
- Default for @ManyToOne and @OneToOne

#### Performance Implications:
```java
// Good: LAZY for collections
@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders; // Don't load unless needed

// Good: EAGER for frequently accessed single entities
@ManyToOne(fetch = FetchType.EAGER)
private Customer customer; // Usually needed with Order

// Bad: EAGER for large collections
@OneToMany(fetch = FetchType.EAGER)
private List<Order> orders; // Can load thousands of records unnecessarily
```

### What is JPQL? How is it different from SQL?

#### JPQL (Java Persistence Query Language)
- Object-oriented query language for JPA entities
- Uses entity names and property names instead of table/column names
- Platform independent

#### SQL (Structured Query Language)
- Relational query language for database tables
- Uses table names and column names
- Database-specific syntax variations

#### Comparison Examples:

**JPQL:**
```java
// JPQL - uses entity and property names
String jpql = "SELECT u FROM User u WHERE u.firstName = :name AND u.department.name = :deptName";

TypedQuery<User> query = em.createQuery(jpql, User.class);
query.setParameter("name", "John");
query.setParameter("deptName", "IT");
List<User> users = query.getResultList();
```

**SQL:**
```sql
-- SQL - uses table and column names
SELECT u.* FROM users u 
JOIN departments d ON u.department_id = d.id 
WHERE u.first_name = ? AND d.name = ?
```

#### JPQL Features:
```java
// SELECT with projections
"SELECT u.firstName, u.lastName FROM User u"

// JOIN operations
"SELECT u FROM User u JOIN u.department d WHERE d.name = :deptName"

// Aggregate functions
"SELECT COUNT(u) FROM User u WHERE u.active = true"

// Subqueries
"SELECT u FROM User u WHERE u.salary > (SELECT AVG(u2.salary) FROM User u2)"

// Named parameters
"SELECT u FROM User u WHERE u.email = :email"

// Positional parameters
"SELECT u FROM User u WHERE u.email = ?1"
```

---

## JDBC Questions

### What is JDBC? Explain JDBC architecture

**JDBC (Java Database Connectivity):**
- Java API for connecting and executing queries on databases
- Provides database-independent connectivity between Java applications and databases
- Part of Java SE platform

#### JDBC Architecture Components:

**1. JDBC API**
- Interfaces and classes in java.sql and javax.sql packages
- Application uses these to interact with databases

**2. JDBC Driver Manager**
- Manages database drivers
- Establishes connections between applications and databases

**3. JDBC Drivers**
- Database-specific implementations of JDBC interfaces
- Translates JDBC calls to database-specific calls

**4. Database**
- Actual database system (MySQL, PostgreSQL, Oracle, etc.)

#### Core JDBC Components:

**DriverManager**
```java
// Registers and manages drivers
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "user", "password");
```

**Connection**
```java
// Represents database session
Connection conn = DriverManager.getConnection(url, user, password);
conn.setAutoCommit(false); // Manual transaction control
```

**Statement**
```java
// Executes SQL queries
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```

**ResultSet**
```java
// Represents query results
while(rs.next()) {
    String name = rs.getString("name");
    int age = rs.getInt("age");
}
```

### What are different types of JDBC drivers?

#### Type 1: JDBC-ODBC Bridge Driver
```java
// Example (deprecated in Java 8+)
Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
Connection conn = DriverManager.getConnection("jdbc:odbc:mydsn");
```
- **Mechanism**: Uses ODBC driver to connect to database
- **Advantages**: Can connect to any ODBC-compliant database
- **Disadvantages**: Performance overhead, platform dependent, deprecated
- **Use case**: Legacy systems (not recommended)

#### Type 2: Native-API Driver (Partly Java Driver)
```java
// Example with Oracle OCI driver
Class.forName("oracle.jdbc.driver.OracleDriver");
Connection conn = DriverManager.getConnection("jdbc:oracle:oci:@mydb");
```
- **Mechanism**: Uses database-specific native libraries
- **Advantages**: Better performance than Type 1
- **Disadvantages**: Platform dependent, requires native libraries
- **Use case**: When native libraries are available and performance is crucial

#### Type 3: Network Protocol Driver (Pure Java Driver)
```java
// Example with middleware server
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://middlewareserver:port/database");
```
- **Mechanism**: Uses middleware server to communicate with database
- **Advantages**: Platform independent, no client-side libraries needed
- **Disadvantages**: Network overhead, requires middleware
- **Use case**: Three-tier architecture with application server

#### Type 4: Thin Driver (Pure Java Driver)
```java
// Example with MySQL Connector/J
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "user", "password");

// PostgreSQL example
Class.forName("org.postgresql.Driver");
Connection conn = DriverManager.getConnection(
    "jdbc:postgresql://localhost:5432/mydb", "user", "password");
```
- **Mechanism**: Direct communication with database using database protocol
- **Advantages**: Platform independent, best performance, no additional software
- **Disadvantages**: Database-specific
- **Use case**: Most common choice for modern applications

### Explain JDBC connection pooling. Why is it important?

#### What is Connection Pooling?
Connection pooling is a technique where a pool of database connections is created and maintained, allowing applications to reuse existing connections instead of creating new ones for each request.

#### Why Connection Pooling is Important:

**Performance Benefits:**
- **Reduced Connection Overhead**: Creating database connections is expensive
- **Faster Response Times**: Reusing existing connections is much faster
- **Resource Optimization**: Limits the number of concurrent connections

**Connection Lifecycle Management:**
```java
// Without Connection Pooling (Bad)
public List<User> getUsers() {
    Connection conn = null;
    try {
        conn = DriverManager.getConnection(url, user, password); // Expensive!
        // Execute query
        return results;
    } finally {
        if(conn != null) conn.close(); // Connection destroyed
    }
}

// With Connection Pooling (Good)
public List<User> getUsers() {
    Connection conn = null;
    try {
        conn = dataSource.getConnection(); // Fast! Gets from pool
        // Execute query
        return results;
    } finally {
        if(conn != null) conn.close(); // Returns to pool, not destroyed
    }
}
```

#### Popular Connection Pool Implementations:

**HikariCP (Recommended):**
```java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
config.setUsername("user");
config.setPassword("password");
config.setMaximumPoolSize(20);
config.setMinimumIdle(5);
config.setConnectionTimeout(30000);

HikariDataSource dataSource = new HikariDataSource(config);
Connection conn = dataSource.getConnection();
```

**Apache DBCP:**
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setUrl("jdbc:mysql://localhost:3306/mydb");
dataSource.setUsername("user");
dataSource.setPassword("password");
dataSource.setInitialSize(5);
dataSource.setMaxTotal(20);
```

### What is the difference between Statement, PreparedStatement, and CallableStatement?

#### Statement
```java
Statement stmt = conn.createStatement();

// Simple query
ResultSet rs = stmt.executeQuery("SELECT * FROM users");

// Dynamic query (DANGEROUS - SQL Injection risk)
String name = "John'; DROP TABLE users; --";
String sql = "SELECT * FROM users WHERE name = '" + name + "'";
ResultSet rs = stmt.executeQuery(sql); // SQL Injection vulnerability!
```

**Characteristics:**
- Used for simple SQL queries
- SQL is compiled every time
- Vulnerable to SQL injection
- No parameter binding

#### PreparedStatement
```java
// Prepared with parameters
String sql = "SELECT * FROM users WHERE name = ? AND age > ?";
PreparedStatement pstmt = conn.prepareStatement(sql);

// Set parameters (SQL injection safe)
pstmt.setString(1, "John");
pstmt.setInt(2, 25);
ResultSet rs = pstmt.executeQuery();

// Batch operations
pstmt.setString(1, "Alice");
pstmt.setInt(2, 30);
pstmt.addBatch();

pstmt.setString(1, "Bob");
pstmt.setInt(2, 35);
pstmt.addBatch();

int[] results = pstmt.executeBatch();
```

**Characteristics:**
- Pre-compiled SQL with parameter placeholders
- Better performance for repeated execution
- Prevents SQL injection through parameter binding
- Supports batch operations

#### CallableStatement
```java
// Call stored procedure
String sql = "{call getUsersByDepartment(?, ?)}";
CallableStatement cstmt = conn.prepareCall(sql);

// Input parameters
cstmt.setString(1, "IT");
cstmt.setInt(2, 5);

// Output parameters
cstmt.registerOutParameter(3, Types.INTEGER);

cstmt.execute();

// Get output parameter
int totalCount = cstmt.getInt(3);

// Function call
String functionSql = "{? = call calculateBonus(?)}";
CallableStatement funcStmt = conn.prepareCall(functionSql);
funcStmt.registerOutParameter(1, Types.DECIMAL);
funcStmt.setInt(2, employeeId);
funcStmt.execute();
BigDecimal bonus = funcStmt.getBigDecimal(1);
```

**Characteristics:**
- Used for stored procedures and functions
- Supports input, output, and input-output parameters
- Inherits PreparedStatement features
- Database-specific functionality

#### SQL Injection Prevention:
```java
// VULNERABLE (Statement)
String userInput = "'; DROP TABLE users; --";
String sql = "SELECT * FROM users WHERE name = '" + userInput + "'";
Statement stmt = conn.createStatement();
stmt.executeQuery(sql); // Executes malicious SQL!

// SAFE (PreparedStatement)
String sql = "SELECT * FROM users WHERE name = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, userInput); // Treated as data, not SQL
ResultSet rs = pstmt.executeQuery(); // Safe execution
```

### How do you handle transactions in JDBC?

#### Transaction Basics:
```java
Connection conn = null;
try {
    conn = DriverManager.getConnection(url, user, password);
    
    // Disable auto-commit for manual transaction control
    conn.setAutoCommit(false);
    
    // Execute multiple operations
    PreparedStatement stmt1 = conn.prepareStatement("INSERT INTO accounts (id, balance) VALUES (?, ?)");
    stmt1.setInt(1, 1);
    stmt1.setBigDecimal(2, new BigDecimal("1000.00"));
    stmt1.executeUpdate();
    
    PreparedStatement stmt2 = conn.prepareStatement("UPDATE accounts SET balance = balance - ? WHERE id = ?");
    stmt2.setBigDecimal(1, new BigDecimal("100.00"));
    stmt2.setInt(2, 1);
    stmt2.executeUpdate();
    
    // Commit transaction
    conn.commit();
    
} catch (SQLException e) {
    // Rollback on error
    if (conn != null) {
        try {
            conn.rollback();
        } catch (SQLException rollbackEx) {
            rollbackEx.printStackTrace();
        }
    }
    e.printStackTrace();
} finally {
    if (conn != null) {
        try {
            conn.setAutoCommit(true); // Restore auto-commit
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

#### Savepoints:
```java
Connection conn = DriverManager.getConnection(url, user, password);
conn.setAutoCommit(false);

try {
    // First operation
    PreparedStatement stmt1 = conn.prepareStatement("INSERT INTO users (name) VALUES (?)");
    stmt1.setString(1, "John");
    stmt1.executeUpdate();
    
    // Create savepoint
    Savepoint savepoint1 = conn.setSavepoint("SavePoint1");
    
    // Second operation
    PreparedStatement stmt2 = conn.prepareStatement("INSERT INTO orders (user_id, amount) VALUES (?, ?)");
    stmt2.setInt(1, 1);
    stmt2.setBigDecimal(2, new BigDecimal("100.00"));
    stmt2.executeUpdate();
    
    // Third operation (might fail)
    PreparedStatement stmt3 = conn.prepareStatement("INSERT INTO invalid_table VALUES (?)");
    stmt3.setString(1, "data");
    stmt3.executeUpdate(); // This might fail
    
    conn.commit(); // Commit all changes
    
} catch (SQLException e) {
    // Rollback to savepoint instead of rolling back everything
    conn.rollback(savepoint1);
    
    // Still commit the first operation
    conn.commit();
} finally {
    conn.close();
}
```

#### Transaction Isolation Levels:
```java
// Set isolation level
conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);

// Available isolation levels:
// TRANSACTION_READ_UNCOMMITTED - Dirty reads possible
// TRANSACTION_READ_COMMITTED   - Prevents dirty reads
// TRANSACTION_REPEATABLE_READ  - Prevents dirty and non-repeatable reads
// TRANSACTION_SERIALIZABLE     - Highest isolation, prevents all phenomena
```

### What are JDBC batch operations?

#### Batch Operations with Statement:
```java
Connection conn = DriverManager.getConnection(url, user, password);
conn.setAutoCommit(false);

Statement stmt = conn.createStatement();

// Add multiple SQL statements to batch
stmt.addBatch("INSERT INTO users (name, email) VALUES ('John', 'john@email.com')");
stmt.addBatch("INSERT INTO users (name, email) VALUES ('Jane', 'jane@email.com')");
stmt.addBatch("INSERT INTO users (name, email) VALUES ('Bob', 'bob@email.com')");
stmt.addBatch("UPDATE users SET active = true WHERE name = 'John'");

// Execute all batches
int[] results = stmt.executeBatch();

// Check results
for (int i = 0; i < results.length; i++) {
    System.out.println("Statement " + i + " affected " + results[i] + " rows");
}

conn.commit();
```

#### Batch Operations with PreparedStatement:
```java
String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
PreparedStatement pstmt = conn.prepareStatement(sql);

// Batch multiple sets of parameters
String[][] userData = {
    {"John", "john@email.com", "25"},
    {"Jane", "jane@email.com", "30"},
    {"Bob", "bob@email.com", "35"}
};

for (String[] user : userData) {
    pstmt.setString(1, user[0]);
    pstmt.setString(2, user[1]);
    pstmt.setInt(3, Integer.parseInt(user[2]));
    pstmt.addBatch(); // Add to batch
}

// Execute batch
int[] results = pstmt.executeBatch();

// Clear batch for reuse
pstmt.clearBatch();
```

#### Large Batch Processing:
```java
String sql = "INSERT INTO large_table (col1, col2, col3) VALUES (?, ?, ?)";
PreparedStatement pstmt = conn.prepareStatement(sql);

int batchSize = 1000;
int count = 0;

for (DataRecord record : largeDataSet) {
    pstmt.setString(1, record.getCol1());
    pstmt.setString(2, record.getCol2());
    pstmt.setString(3, record.getCol3());
    pstmt.addBatch();
    
    count++;
    
    // Execute batch when reaching batch size
    if (count % batchSize == 0) {
        pstmt.executeBatch();
        pstmt.clearBatch();
    }
}

// Execute remaining batch
if (count % batchSize != 0) {
    pstmt.executeBatch();
}
```

#### Benefits of Batch Operations:
- **Performance**: Reduces network round trips
- **Efficiency**: Database can optimize execution
- **Atomic Operations**: All succeed or all fail (within transaction)

---

## Hibernate Questions

### What is Hibernate? What are its advantages?

**Hibernate:**
Hibernate is a powerful Object-Relational Mapping (ORM) framework for Java that simplifies database operations by mapping Java objects to database tables.

#### Advantages:

**1. ORM Benefits:**
```java
// Without ORM (JDBC)
String sql = "SELECT id, name, email FROM users WHERE id = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setLong(1, userId);
ResultSet rs = pstmt.executeQuery();
User user = null;
if (rs.next()) {
    user = new User();
    user.setId(rs.getLong("id"));
    user.setName(rs.getString("name"));
    user.setEmail(rs.getString("email"));
}

// With Hibernate
User user = session.get(User.class, userId); // That's it!
```

**2. Caching:**
```java
// First-level cache (Session level)
User user1 = session.get(User.class, 1L); // Database hit
User user2 = session.get(User.class, 1L); // Cache hit, no DB query

// Second-level cache (SessionFactory level)
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    // Cached across sessions
}
```

**3. Lazy Loading:**
```java
@Entity
public class User {
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders; // Loaded only when accessed
}

User user = session.get(User.class, 1L); // Orders not loaded
List<Order> orders = user.getOrders(); // Now orders are loaded
```

**4. HQL (Hibernate Query Language):**
```java
// HQL - Object-oriented
String hql = "FROM User u WHERE u.name = :name";
Query query = session.createQuery(hql);
query.setParameter("name", "John");
List<User> users = query.list();

// Supports advanced features
String hql2 = "SELECT u.name, COUNT(o) FROM User u LEFT JOIN u.orders o GROUP BY u.name";
```

### Explain Hibernate architecture

#### Core Components:

**1. Configuration**
```java
// Hibernate configuration
Configuration config = new Configuration();
config.configure("hibernate.cfg.xml");
config.addAnnotatedClass(User.class);
```

**2. SessionFactory**
```java
// Heavy-weight object, created once per application
SessionFactory sessionFactory = config.buildSessionFactory();
```

**3. Session**
```java
// Light-weight, one per database interaction
Session session = sessionFactory.openSession();
```

**4. Transaction**
```java
Transaction tx = session.beginTransaction();
// Database operations
tx.commit();
```

#### Architecture Diagram Flow:
```
Application
    ↓
Configuration → SessionFactory → Session → Transaction
    ↓               ↓              ↓          ↓
hibernate.cfg.xml   Connection   Persistent  Database
                    Pool         Context
```

#### Complete Example:
```java
// 1. Configuration
Configuration config = new Configuration()
    .configure()
    .addAnnotatedClass(User.class);

// 2. SessionFactory
SessionFactory sessionFactory = config.buildSessionFactory();

// 3. Session
Session session = sessionFactory.openSession();

// 4. Transaction
Transaction tx = session.beginTransaction();

try {
    // Database operations
    User user = new User("John", "john@email.com");
    session.save(user);
    
    tx.commit();
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    session.close();
}
```

### What is the difference between Session and SessionFactory?

#### SessionFactory

**Characteristics:**
- Heavy-weight object
- Thread-safe
- Immutable after creation
- Created once per application/database
- Expensive to create
- Caches metadata and compiled queries

```java
// Created once, typically at application startup
SessionFactory sessionFactory = new Configuration()
    .configure()
    .addAnnotatedClass(User.class)
    .buildSessionFactory();

// Thread-safe - can be used by multiple threads
public class UserService {
    private static final SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
    
    public User findUser(Long id) {
        Session session = sessionFactory.openSession(); // Thread-safe call
        return session.get(User.class, id);
    }
}
```

#### Session

**Characteristics:**
- Light-weight object
- Not thread-safe
- Short-lived (per request/transaction)
- Created from SessionFactory
- Represents single database conversation
- Maintains first-level cache

```java
// Created per operation/request
public void performDatabaseOperations() {
    Session session = sessionFactory.openSession(); // New session
    
    try {
        Transaction tx = session.beginTransaction();
        
        // First-level cache in action
        User user1 = session.get(User.class, 1L); // DB query
        User user2 = session.get(User.class, 1L); // Cache hit
        
        tx.commit();
    } finally {
        session.close(); // Always close
    }
}

// NOT thread-safe
public class BadExample {
    private Session session; // DON'T DO THIS
    
    public void method1() {
        User user = session.get(User.class, 1L); // Concurrent access issues
    }
}
```

#### Lifecycle Differences:
```java
// SessionFactory - Application Lifecycle
public class HibernateUtil {
    private static SessionFactory sessionFactory;
    
    static {
        try {
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }
    
    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }
    
    public static void shutdown() {
        getSessionFactory().close(); // Only at application shutdown
    }
}

// Session - Request/Transaction Lifecycle
public class UserDAO {
    public void saveUser(User user) {
        Session session = HibernateUtil.getSessionFactory().openSession();
        Transaction tx = null;
        
        try {
            tx = session.beginTransaction();
            session.save(user);
            tx.commit();
        } catch (Exception e) {
            if (tx != null) tx.rollback();
            throw e;
        } finally {
            session.close(); // Close after each operation
        }
    }
}
```

### Explain Hibernate caching mechanisms

#### First-Level Cache (Session Cache)

**Characteristics:**
- Enabled by default
- Session-scoped
- Automatic management
- Cannot be disabled

```java
Session session = sessionFactory.openSession();

// First database hit
User user1 = session.get(User.class, 1L);
System.out.println("First call: " + user1.getName());

// Cache hit - no database query
User user2 = session.get(User.class, 1L);
System.out.println("Second call: " + user2.getName());

// Same object reference
System.out.println(user1 == user2); // true

session.close(); // Cache is cleared
```

**First-Level Cache Methods:**
```java
Session session = sessionFactory.openSession();

User user = session.get(User.class, 1L);

// Check if object is in session cache
boolean contains = session.contains(user); // true

// Remove object from cache
session.evict(user);

// Clear entire session cache
session.clear();

// Refresh object from database
session.refresh(user);
```

#### Second-Level Cache (SessionFactory Cache)

**Configuration:**
```xml
<!-- hibernate.cfg.xml -->
<property name="hibernate.cache.use_second_level_cache">true</property>
<property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
```

**Entity-Level Caching:**
```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
}

// Usage across different sessions
Session session1 = sessionFactory.openSession();
User user1 = session1.get(User.class, 1L); // Database hit
session1.close();

Session session2 = sessionFactory.openSession();
User user2 = session2.get(User.class, 1L); // Cache hit - no DB query
session2.close();
```

**Collection Caching:**
```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Employee> employees;
}
```

**Query Caching:**
```java
// Enable query cache
Query query = session.createQuery("FROM User WHERE active = true");
query.setCacheable(true);
query.setCacheRegion("userQueries");
List<User> users = query.list();

// Second execution uses cache
Query query2 = session.createQuery("FROM User WHERE active = true");
query2.setCacheable(true);
List<User> users2 = query2.list(); // Cache hit
```

#### Cache Concurrency Strategies:
```java
// READ_ONLY - Best performance, no updates allowed
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
public class Country {
    // Static reference data
}

// READ_WRITE - Most common, handles updates
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    // Regular entities that can be updated
}

// NONSTRICT_READ_WRITE - Slight performance gain, eventual consistency
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Category {
    // Data that doesn't change frequently
}

// TRANSACTIONAL - JTA environments only
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL)
public class Account {
    // Strict consistency required
}
```

### What are different ways to map entities in Hibernate?

#### 1. XML Configuration Mapping

**hibernate.cfg.xml:**
```xml
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/mydb</property>
        
        <!-- Mapping files -->
        <mapping resource="User.hbm.xml"/>
    </session-factory>
</hibernate-configuration>
```

**User.hbm.xml:**
```xml
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    <class name="com.example.User" table="users">
        <id name="id" type="long" column="id">
            <generator class="identity"/>
        </id>
        
        <property name="name" type="string" column="name" length="100" not-null="true"/>
        <property name="email" type="string" column="email" length="255" unique="true"/>
        <property name="createdDate" type="timestamp" column="created_date"/>
        
        <!-- One-to-Many relationship -->
        <set name="orders" table="orders" cascade="all">
            <key column="user_id"/>
            <one-to-many class="com.example.Order"/>
        </set>
        
        <!-- Many-to-One relationship -->
        <many-to-one name="department" class="com.example.Department" column="dept_id" cascade="save-update"/>
    </class>
</hibernate-mapping>
```

#### 2. Annotation-Based Mapping

**Entity Class:**
```java
@Entity
@Table(name = "users", 
       uniqueConstraints = @UniqueConstraint(columnNames = "email"),
       indexes = @Index(name = "idx_user_name", columnList = "name"))
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "email", unique = true, length = 255)
    private String email;
    
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "created_date")
    private Date createdDate;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Order> orders = new ArrayList<>();
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dept_id")
    private Department department;
    
    // Constructors, getters, setters
}
```

**Configuration:**
```java
Configuration config = new Configuration();
config.addAnnotatedClass(User.class);
config.addAnnotatedClass(Order.class);
config.addAnnotatedClass(Department.class);
SessionFactory sessionFactory = config.buildSessionFactory();
```

#### 3. Mixed Mapping (XML + Annotations)
```java
// You can use both approaches in the same application
@Entity
public class User {
    @Id
    private Long id;
    // Some fields with annotations
}

// And also have XML mappings for other entities
// Order.hbm.xml for Order entity
```

#### Advanced Mapping Examples:

**Embedded Objects:**
```java
@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
}

@Entity
public class User {
    @Id
    private Long id;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "street", column = @Column(name = "home_street")),
        @AttributeOverride(name = "city", column = @Column(name = "home_city"))
    })
    private Address homeAddress;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "street", column = @Column(name = "work_street")),
        @AttributeOverride(name = "city", column = @Column(name = "work_city"))
    })
    private Address workAddress;
}
```

**Inheritance Mapping:**
```java
// Table per class hierarchy (Single Table)
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "user_type")
public abstract class User {
    @Id
    private Long id;
    private String name;
}

@Entity
@DiscriminatorValue("ADMIN")
public class AdminUser extends User {
    private String adminLevel;
}

@Entity
@DiscriminatorValue("REGULAR")
public class RegularUser extends User {
    private int loyaltyPoints;
}
```

### Explain cascade operations in Hibernate associations

#### Cascade Types:

**CascadeType.PERSIST:**
```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", cascade = CascadeType.PERSIST)
    private List<Employee> employees;
}

// Usage
Department dept = new Department("IT");
Employee emp1 = new Employee("John");
Employee emp2 = new Employee("Jane");

dept.addEmployee(emp1);
dept.addEmployee(emp2);

session.save(dept); // Also saves emp1 and emp2 automatically
```

**CascadeType.MERGE:**
```java
@Entity
public class Order {
    @OneToMany(mappedBy = "order", cascade = CascadeType.MERGE)
    private List<OrderItem> items;
}

// Usage - detached objects
Order detachedOrder = // ... get from somewhere
OrderItem detachedItem = // ... get from somewhere

detachedOrder.addItem(detachedItem);

Order mergedOrder = session.merge(detachedOrder); // Also merges items
```

**CascadeType.REMOVE:**
```java
@Entity
public class User {
    @OneToMany(mappedBy = "user", cascade = CascadeType.REMOVE)
    private List<Order> orders;
}

// Usage
User user = session.get(User.class, 1L);
session.delete(user); // Also deletes all associated orders
```

**CascadeType.REFRESH:**
```java
@Entity
public class Customer {
    @OneToMany(mappedBy = "customer", cascade = CascadeType.REFRESH)
    private List<Order> orders;
}

// Usage
Customer customer = session.get(Customer.class, 1L);
session.refresh(customer); // Also refreshes all orders from database
```

**CascadeType.DETACH:**
```java
@Entity
public class Author {
    @OneToMany(mappedBy = "author", cascade = CascadeType.DETACH)
    private List<Book> books;
}

// Usage
Author author = session.get(Author.class, 1L);
session.evict(author); // Also detaches all books from session
```

**CascadeType.ALL:**
```java
@Entity
public class ShoppingCart {
    @OneToMany(mappedBy = "cart", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CartItem> items;
}

// Includes: PERSIST, MERGE, REMOVE, REFRESH, DETACH
```

#### Orphan Removal:
```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Child> children;
    
    public void removeChild(Child child) {
        children.remove(child);
        child.setParent(null);
        // Child will be deleted from database due to orphanRemoval = true
    }
}
```

#### Cascade Best Practices:
```java
@Entity
public class User {
    // Good: Cascade for composition relationships
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<UserProfile> profiles;
    
    // Careful: Don't cascade for association relationships
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    // Don't use CascadeType.REMOVE here - roles might be shared
    private Set<Role> roles;
}
```

### What is N+1 problem in Hibernate? How to solve it?

#### N+1 Problem Explanation:

**The Problem:**
```java
// This code causes N+1 queries
List<Department> departments = session.createQuery("FROM Department").list(); // 1 query

for (Department dept : departments) {
    System.out.println(dept.getName());
    List<Employee> employees = dept.getEmployees(); // N queries (one for each department)
    System.out.println("Employee count: " + employees.size());
}
```

**What happens:**
- 1 query to fetch all departments
- N additional queries to fetch employees for each department
- Total: N+1 queries instead of 1 or 2 optimized queries

#### Solutions:

**1. JOIN FETCH:**
```java
// HQL with JOIN FETCH
String hql = "FROM Department d JOIN FETCH d.employees";
List<Department> departments = session.createQuery(hql).list();

// Criteria API
Criteria criteria = session.createCriteria(Department.class);
criteria.setFetchMode("employees", FetchMode.JOIN);
List<Department> departments = criteria.list();

// No additional queries needed when accessing employees
for (Department dept : departments) {
    List<Employee> employees = dept.getEmployees(); // No additional query
}
```

**2. @BatchSize Annotation:**
```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    @BatchSize(size = 10) // Fetch 10 collections at a time
    private List<Employee> employees;
}

// Now instead of N queries, we get N/10 queries
List<Department> departments = session.createQuery("FROM Department").list();
for (Department dept : departments) {
    dept.getEmployees().size(); // Batched loading
}
```

**3. @Fetch Annotation:**
```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    @Fetch(FetchMode.SUBSELECT) // Use subquery to fetch all at once
    private List<Employee> employees;
}

// Or
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    @Fetch(FetchMode.JOIN) // Always use JOIN
    private List<Employee> employees;
}
```

**4. EntityGraph (JPA 2.1):**
```java
@NamedEntityGraph(
    name = "Department.employees",
    attributeNodes = @NamedAttributeNode("employees")
)
@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List<Employee> employees;
}

// Usage
EntityGraph entityGraph = session.getEntityGraph("Department.employees");
List<Department> departments = session.createQuery("FROM Department")
    .setHint("javax.persistence.fetchgraph", entityGraph)
    .getResultList();
```

**5. Projection Queries:**
```java
// Instead of loading full entities, load only needed data
String hql = "SELECT d.name, COUNT(e) FROM Department d LEFT JOIN d.employees e GROUP BY d.name";
List<Object[]> results = session.createQuery(hql).list();
```

**6. Two-Step Loading:**
```java
// Step 1: Load departments
List<Department> departments = session.createQuery("FROM Department").list();

// Step 2: Load all employees in one query
if (!departments.isEmpty()) {
    String hql = "FROM Employee e WHERE e.department IN (:departments)";
    List<Employee> allEmployees = session.createQuery(hql)
        .setParameterList("departments", departments)
        .list();
    
    // Manually associate employees with departments
    Map<Department, List<Employee>> employeeMap = allEmployees.stream()
        .collect(Collectors.groupingBy(Employee::getDepartment));
}
```

---

## Advanced/Integration Questions

### How does SpringBoot integrate with JPA/Hibernate?

#### Auto-Configuration:
```java
// Just add dependency - auto-configuration handles the rest
// pom.xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

**What SpringBoot auto-configures:**
- DataSource configuration
- EntityManagerFactory
- TransactionManager
- JPA repositories
- Hibernate as default JPA provider

#### Configuration Properties:
```properties
# application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# Connection pool
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
```

#### Entity and Repository:
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    // getters, setters
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByNameContaining(String name);
}

@Service
@Transactional
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    public User saveUser(User user) {
        return userRepository.save(user);
    }
}
```

#### Custom Configuration:
```java
@Configuration
@EnableJpaRepositories(basePackages = "com.example.repository")
public class JpaConfig {
    
    @Bean
    @Primary
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("user");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource());
        em.setPackagesToScan("com.example.entity");
        
        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);
        
        Properties properties = new Properties();
        properties.put("hibernate.hbm2ddl.auto", "update");
        properties.put("hibernate.show_sql", "true");
        em.setJpaProperties(properties);
        
        return em;
    }
}
```

### Explain @Transactional annotation in Spring

#### Basic Usage:
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional
    public User createUser(User user) {
        // All database operations in this method are in one transaction
        User savedUser = userRepository.save(user);
        // If exception occurs here, transaction is rolled back
        updateUserStatistics(savedUser);
        return savedUser;
    }
    
    @Transactional(readOnly = true)
    public User findUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```

#### Propagation Levels:
```java
@Service
public class OrderService {
    
    @Autowired
    private PaymentService paymentService;
    
    @Transactional(propagation = Propagation.REQUIRED) // Default
    public void processOrder(Order order) {
        // Uses existing transaction or creates new one
        saveOrder(order);
        paymentService.processPayment(order.getPayment());
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logOrderEvent(OrderEvent event) {
        // Always creates new transaction, suspends current one
        eventRepository.save(event);
        // This transaction commits independently
    }
    
    @Transactional(propagation = Propagation.SUPPORTS)
    public List<Order> getOrders() {
        // Uses transaction if exists, otherwise runs without transaction
        return orderRepository.findAll();
    }
    
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void generateReport() {
        // Always runs without transaction, suspends current one
        reportGenerator.generate();
    }
    
    @Transactional(propagation = Propagation.NEVER)
    public void validateData(Data data) {
        // Throws exception if transaction exists
        validator.validate(data);
    }
    
    @Transactional(propagation = Propagation.MANDATORY)
    public void updateInventory(Item item) {
        // Throws exception if no transaction exists
        inventoryRepository.update(item);
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void processNestedOperation() {
        // Creates nested transaction (savepoint)
        // Can rollback to savepoint without affecting outer transaction
    }
}
```

#### Isolation Levels:
```java
@Service
public class AccountService {
    
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public void readUncommitted() {
        // Can read uncommitted changes (dirty reads possible)
        // Fastest but least safe
    }
    
    @Transactional(isolation = Isolation.READ_COMMITTED) // Default for most databases
    public void readCommitted() {
        // Can only read committed changes
        // Prevents dirty reads
    }
    
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void repeatableRead() {
        // Same data read multiple times in transaction returns same result
        // Prevents dirty reads and non-repeatable reads
    }
    
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void serializable() {
        // Highest isolation level
        // Prevents dirty reads, non-repeatable reads, and phantom reads
        // Slowest performance
    }
}
```

#### Rollback Scenarios:
```java
@Service
public class TransactionService {
    
    @Transactional
    public void defaultRollback() throws Exception {
        // Rolls back on RuntimeException and Error (unchecked exceptions)
        userRepository.save(user);
        if (condition) {
            throw new RuntimeException("This will rollback");
        }
        // Checked exceptions do NOT rollback by default
        throw new Exception("This will NOT rollback");
    }
    
    @Transactional(rollbackFor = {Exception.class, CustomException.class})
    public void customRollback() throws Exception {
        // Explicitly specify which exceptions cause rollback
        userRepository.save(user);
        throw new Exception("This WILL rollback now");
    }
    
    @Transactional(noRollbackFor = {IllegalArgumentException.class})
    public void noRollbackFor() {
        // Don't rollback for specific exceptions
        userRepository.save(user);
        throw new IllegalArgumentException("This will NOT rollback");
    }
    
    @Transactional
    public void programmaticRollback() {
        try {
            userRepository.save(user);
            riskyOperation();
        } catch (Exception e) {
            // Mark transaction for rollback
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            handleException(e);
        }
    }
}
```

#### Class-Level vs Method-Level:
```java
@Service
@Transactional(readOnly = true) // Default for all methods
public class UserService {
    
    // Inherits readOnly = true
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    @Transactional(readOnly = false) // Override class-level setting
    public User saveUser(User user) {
        return userRepository.save(user);
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW, timeout = 30)
    public void longRunningOperation() {
        // Custom settings for this method
        performLongOperation();
    }
}
```

### How do you handle database migrations in SpringBoot?

#### 1. Flyway Integration:

**Dependencies:**
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

**Configuration:**
```properties
# application.properties
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.validate-on-migrate=true
```

**Migration Files Structure:**
```
src/main/resources/db/migration/
├── V1__Create_user_table.sql
├── V2__Add_email_column.sql
├── V3__Create_order_table.sql
└── V4__Add_user_indexes.sql
```

**Migration File Examples:**
```sql
-- V1__Create_user_table.sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- V2__Add_email_column.sql
ALTER TABLE users ADD COLUMN email VARCHAR(255) UNIQUE;

-- V3__Create_order_table.sql
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

**Java-Based Migrations:**
```java
// V5__Insert_default_users.java
@Component
public class V5__Insert_default_users implements JavaMigration {
    
    @Override
    public void migrate(Context context) throws Exception {
        try (Statement statement = context.getConnection().createStatement()) {
            statement.executeUpdate("INSERT INTO users (name, email) VALUES ('Admin', 'admin@example.com')");
            statement.executeUpdate("INSERT INTO users (name, email) VALUES ('User', 'user@example.com')");
        }
    }
}
```

#### 2. Liquibase Integration:

**Dependencies:**
```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
```

**Configuration:**
```properties
spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml
spring.liquibase.enabled=true
```

**Master Changelog:**
```xml
<!-- db.changelog-master.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">

    <include file="db/changelog/01-create-user-table.xml"/>
    <include file="db/changelog/02-add-email-column.xml"/>
    <include file="db/changelog/03-create-order-table.xml"/>
</databaseChangeLog>
```

**Individual Changelogs:**
```xml
<!-- 01-create-user-table.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">

    <changeSet id="1" author="developer">
        <createTable tableName="users">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true"/>
            </column>
            <column name="name" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="created_date" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP"/>
        </createTable>
    </changeSet>
</databaseChangeLog>
```

#### 3. Hibernate DDL Auto:

**Configuration:**
```properties
# Development only - not recommended for production
spring.jpa.hibernate.ddl-auto=update

# Options:
# create - Drop and create tables
# create-drop - Create tables, drop on shutdown  
# update - Update schema (add new columns/tables)
# validate - Validate schema matches entities
# none - Do nothing
```

**Production Best Practices:**
```properties
# Production
spring.jpa.hibernate.ddl-auto=validate
spring.flyway.enabled=true

# Development
spring.jpa.hibernate.ddl-auto=update
spring.flyway.enabled=false
```

#### 4. Custom Migration Configuration:

**Flyway Custom Configuration:**
```java
@Configuration
public class FlywayConfig {
    
    @Bean
    public Flyway flyway(@Qualifier("dataSource") DataSource dataSource) {
        return Flyway.configure()
            .dataSource(dataSource)
            .locations("classpath:db/migration", "classpath:db/data")
            .baselineOnMigrate(true)
            .validateOnMigrate(true)
            .outOfOrder(false)
            .load();
    }
    
    @EventListener
    public void handleApplicationReady(ApplicationReadyEvent event) {
        flyway(null).migrate();
    }
}
```

### What is the difference between save() and saveAndFlush() in JPA?

#### save() Method:
```
